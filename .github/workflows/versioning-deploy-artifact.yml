name: Versioning Deploy Artifact

on:
  workflow_dispatch:
    inputs:
      request_id:
        description: "ID de la solicitud de deploy"
        required: true
        type: string
      product_key:
        description: "Producto (referidos_app | prelaunch_web)"
        required: true
        type: string
      env_key:
        description: "Entorno destino (staging | prod)"
        required: true
        type: string
      semver:
        description: "Version semver"
        required: true
        type: string
      source_commit_sha:
        description: "Commit exacto a desplegar"
        required: true
        type: string
      source_branch:
        description: "Rama origen"
        required: false
        type: string
      target_branch:
        description: "Rama destino"
        required: false
        type: string
      callback_url:
        description: "URL de callback para finalizar deploy"
        required: true
        type: string
      deploy_execution_id:
        description: "ID interno de ejecucion de deploy"
        required: true
        type: string
      actor:
        description: "Actor que disparo el deploy"
        required: false
        type: string

permissions:
  contents: write
  actions: read

jobs:
  deploy-artifact:
    runs-on: ubuntu-latest
    env:
      PRODUCT_KEY: ${{ inputs.product_key }}
      ENV_KEY: ${{ inputs.env_key }}
      REQUEST_ID: ${{ inputs.request_id }}
      SEMVER: ${{ inputs.semver }}
      SOURCE_COMMIT_SHA: ${{ inputs.source_commit_sha }}
      SOURCE_BRANCH: ${{ inputs.source_branch }}
      TARGET_BRANCH: ${{ inputs.target_branch }}
      CALLBACK_URL: ${{ inputs.callback_url }}
      DEPLOY_EXECUTION_ID: ${{ inputs.deploy_execution_id }}
      WORKFLOW_ACTOR: ${{ inputs.actor }}
      NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
      VERSIONING_DEPLOY_CALLBACK_TOKEN: ${{ secrets.VERSIONING_DEPLOY_CALLBACK_TOKEN }}
      NETLIFY_SITE_ID_REFERIDOS_APP_STAGING: ${{ secrets.NETLIFY_SITE_ID_REFERIDOS_APP_STAGING }}
      NETLIFY_SITE_ID_REFERIDOS_APP_PROD: ${{ secrets.NETLIFY_SITE_ID_REFERIDOS_APP_PROD }}
      NETLIFY_SITE_ID_PRELAUNCH_WEB_STAGING: ${{ secrets.NETLIFY_SITE_ID_PRELAUNCH_WEB_STAGING }}
      NETLIFY_SITE_ID_PRELAUNCH_WEB_PROD: ${{ secrets.NETLIFY_SITE_ID_PRELAUNCH_WEB_PROD }}
      OBS_SUPABASE_URL_STAGING: ${{ secrets.OBS_SUPABASE_URL_STAGING }}
      OBS_SUPABASE_URL_PROD: ${{ secrets.OBS_SUPABASE_URL_PROD }}
      OBS_SUPABASE_SECRET_KEY_STAGING: ${{ secrets.OBS_SUPABASE_SECRET_KEY_STAGING }}
      OBS_SUPABASE_SECRET_KEY_PROD: ${{ secrets.OBS_SUPABASE_SECRET_KEY_PROD }}
      OBS_SUPABASE_SERVICE_ROLE_KEY_STAGING: ${{ secrets.OBS_SUPABASE_SERVICE_ROLE_KEY_STAGING }}
      OBS_SUPABASE_SERVICE_ROLE_KEY_PROD: ${{ secrets.OBS_SUPABASE_SERVICE_ROLE_KEY_PROD }}
      VITE_SUPABASE_URL_STAGING: ${{ secrets.VITE_SUPABASE_URL_STAGING }}
      VITE_SUPABASE_URL_PROD: ${{ secrets.VITE_SUPABASE_URL_PROD }}
      VITE_SUPABASE_ANON_KEY_STAGING: ${{ secrets.VITE_SUPABASE_ANON_KEY_STAGING }}
      VITE_SUPABASE_ANON_KEY_PROD: ${{ secrets.VITE_SUPABASE_ANON_KEY_PROD }}
      OBS_TENANT_ID_STAGING: ${{ secrets.OBS_TENANT_ID_STAGING }}
      OBS_TENANT_ID_PROD: ${{ secrets.OBS_TENANT_ID_PROD }}
      OBS_TENANT_NAME_STAGING: ${{ secrets.OBS_TENANT_NAME_STAGING }}
      OBS_TENANT_NAME_PROD: ${{ secrets.OBS_TENANT_NAME_PROD }}
      SUPABASE_URL_STAGING: ${{ secrets.SUPABASE_URL_STAGING }}
      SUPABASE_URL_PROD: ${{ secrets.SUPABASE_URL_PROD }}
      SUPABASE_SECRET_KEY_STAGING: ${{ secrets.SUPABASE_SECRET_KEY_STAGING }}
      SUPABASE_SECRET_KEY_PROD: ${{ secrets.SUPABASE_SECRET_KEY_PROD }}
      SUPABASE_SERVICE_ROLE_KEY_STAGING: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY_STAGING }}
      SUPABASE_SERVICE_ROLE_KEY_PROD: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY_PROD }}
      VERSIONING_ARTIFACTS_BUCKET: ${{ secrets.VERSIONING_ARTIFACTS_BUCKET }}
    steps:
      - name: Validar input y resolver plan
        id: plan
        shell: bash
        run: |
          set -euo pipefail

          product="${PRODUCT_KEY}"
          env_key="${ENV_KEY}"

          if [[ "$env_key" != "staging" && "$env_key" != "prod" ]]; then
            echo "Entorno invalido para deploy: $env_key"
            exit 1
          fi

          workspace=""
          netlify_filter=""
          publish_dir=""
          upload_app=""
          obs_app_id=""
          specific_site_id=""
          required_site_secret=""

          if [[ "$product" == "referidos_app" ]]; then
            workspace="@referidos/referidos-app"
            netlify_filter="@referidos/referidos-app"
            publish_dir="apps/referidos-app/dist"
            upload_app="referidos-app"
            obs_app_id="referidos-app"
            if [[ "$env_key" == "staging" ]]; then
              specific_site_id="${NETLIFY_SITE_ID_REFERIDOS_APP_STAGING}"
              required_site_secret="NETLIFY_SITE_ID_REFERIDOS_APP_STAGING"
            else
              specific_site_id="${NETLIFY_SITE_ID_REFERIDOS_APP_PROD}"
              required_site_secret="NETLIFY_SITE_ID_REFERIDOS_APP_PROD"
            fi
          elif [[ "$product" == "prelaunch_web" ]]; then
            workspace="@referidos/prelaunch"
            netlify_filter="@referidos/prelaunch"
            publish_dir="apps/prelaunch/dist"
            upload_app="prelaunch"
            obs_app_id="prelaunch"
            if [[ "$env_key" == "staging" ]]; then
              specific_site_id="${NETLIFY_SITE_ID_PRELAUNCH_WEB_STAGING}"
              required_site_secret="NETLIFY_SITE_ID_PRELAUNCH_WEB_STAGING"
            else
              specific_site_id="${NETLIFY_SITE_ID_PRELAUNCH_WEB_PROD}"
              required_site_secret="NETLIFY_SITE_ID_PRELAUNCH_WEB_PROD"
            fi
          else
            echo "Producto no soportado para deploy web por artifact exacto: $product"
            exit 1
          fi

          site_id="${specific_site_id}"
          if [[ -z "$site_id" ]]; then
            echo "Falta secret requerido ${required_site_secret} para product=${product} env=${env_key}"
            exit 1
          fi

          if [[ -z "${NETLIFY_AUTH_TOKEN}" ]]; then
            echo "Falta secret NETLIFY_AUTH_TOKEN"
            exit 1
          fi

          echo "workspace=${workspace}" >> "$GITHUB_OUTPUT"
          echo "netlify_filter=${netlify_filter}" >> "$GITHUB_OUTPUT"
          echo "publish_dir=${publish_dir}" >> "$GITHUB_OUTPUT"
          echo "upload_app=${upload_app}" >> "$GITHUB_OUTPUT"
          echo "obs_app_id=${obs_app_id}" >> "$GITHUB_OUTPUT"
          echo "site_id=${site_id}" >> "$GITHUB_OUTPUT"

      - name: Resolver credenciales Supabase observability
        id: obs
        shell: bash
        run: |
          set -euo pipefail

          env_key="${ENV_KEY}"
          obs_url=""
          obs_secret=""

          if [[ "$env_key" == "staging" ]]; then
            obs_url="${OBS_SUPABASE_URL_STAGING:-${SUPABASE_URL_STAGING:-}}"
            obs_secret="${OBS_SUPABASE_SECRET_KEY_STAGING:-${OBS_SUPABASE_SERVICE_ROLE_KEY_STAGING:-${SUPABASE_SECRET_KEY_STAGING:-${SUPABASE_SERVICE_ROLE_KEY_STAGING:-}}}}"
          else
            obs_url="${OBS_SUPABASE_URL_PROD:-${SUPABASE_URL_PROD:-}}"
            obs_secret="${OBS_SUPABASE_SECRET_KEY_PROD:-${OBS_SUPABASE_SERVICE_ROLE_KEY_PROD:-${SUPABASE_SECRET_KEY_PROD:-${SUPABASE_SERVICE_ROLE_KEY_PROD:-}}}}"
          fi

          if [[ -z "$obs_url" ]]; then
            echo "Falta secret OBS_SUPABASE_URL_${env_key^^}"
            exit 1
          fi
          if [[ -z "$obs_secret" ]]; then
            echo "Falta secret OBS_SUPABASE_SECRET_KEY_${env_key^^} (o OBS_SUPABASE_SERVICE_ROLE_KEY_${env_key^^})"
            exit 1
          fi

          echo "obs_url=${obs_url}" >> "$GITHUB_OUTPUT"
          echo "obs_secret=${obs_secret}" >> "$GITHUB_OUTPUT"

      - name: Resolver variables Vite Supabase
        id: vite_supabase
        shell: bash
        run: |
          set -euo pipefail

          env_key="${ENV_KEY}"
          vite_url=""
          vite_anon_key=""

          has_value() {
            if [[ -n "${1:-}" ]]; then
              echo "yes"
            else
              echo "no"
            fi
          }

          if [[ "$env_key" == "staging" ]]; then
            vite_url="${VITE_SUPABASE_URL_STAGING:-}"
            vite_anon_key="${VITE_SUPABASE_ANON_KEY_STAGING:-}"
          else
            vite_url="${VITE_SUPABASE_URL_PROD:-}"
            vite_anon_key="${VITE_SUPABASE_ANON_KEY_PROD:-}"
          fi

          if [[ -z "$vite_url" ]]; then
            echo "Falta VITE_SUPABASE_URL para ${env_key}"
            echo "Diagnostico URL keys: VITE_SUPABASE_URL_STAGING=$(has_value "${VITE_SUPABASE_URL_STAGING:-}") VITE_SUPABASE_URL_PROD=$(has_value "${VITE_SUPABASE_URL_PROD:-}")"
            exit 1
          fi
          if [[ -z "$vite_anon_key" ]]; then
            echo "Falta VITE_SUPABASE_ANON_KEY para ${env_key}"
            echo "Diagnostico ANON keys: VITE_SUPABASE_ANON_KEY_STAGING=$(has_value "${VITE_SUPABASE_ANON_KEY_STAGING:-}") VITE_SUPABASE_ANON_KEY_PROD=$(has_value "${VITE_SUPABASE_ANON_KEY_PROD:-}")"
            exit 1
          fi

          echo "vite_supabase_url=${vite_url}" >> "$GITHUB_OUTPUT"
          echo "vite_supabase_anon_key=${vite_anon_key}" >> "$GITHUB_OUTPUT"

      - name: Resolver tenant observability
        id: obs_tenant
        shell: bash
        run: |
          set -euo pipefail

          env_key="${ENV_KEY}"
          tenant_id=""
          tenant_name=""

          if [[ "$env_key" == "staging" ]]; then
            tenant_id="${OBS_TENANT_ID_STAGING:-}"
            tenant_name="${OBS_TENANT_NAME_STAGING:-ReferidosAPP}"
          else
            tenant_id="${OBS_TENANT_ID_PROD:-}"
            tenant_name="${OBS_TENANT_NAME_PROD:-ReferidosAPP}"
          fi

          echo "tenant_id=${tenant_id}" >> "$GITHUB_OUTPUT"
          echo "tenant_name=${tenant_name}" >> "$GITHUB_OUTPUT"

      - name: Checkout commit exacto
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ inputs.source_commit_sha }}

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Install dependencies
        run: npm ci

      - name: Resolve release artifact metadata
        id: artifact_meta
        shell: bash
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SECRET_KEY: ${{ secrets.SUPABASE_SECRET_KEY }}
        run: |
          set -euo pipefail

          node <<'NODE'
          const fs = require("fs");
          const { createClient } = require("@supabase/supabase-js");

          (async () => {
            const url = process.env.SUPABASE_URL;
            const key = process.env.SUPABASE_SECRET_KEY;
            const requestId = process.env.REQUEST_ID;
            if (!url || !key || !requestId) {
              throw new Error("Missing SUPABASE_URL/SUPABASE_SECRET_KEY/REQUEST_ID");
            }

            const supabase = createClient(url, key, {
              auth: { persistSession: false, autoRefreshToken: false },
            });

            const { data: requestRow, error: requestError } = await supabase
              .from("version_deploy_requests_labeled")
              .select("id, release_id, product_key, env_key, version_label")
              .eq("id", requestId)
              .limit(1)
              .maybeSingle();
            if (requestError || !requestRow?.release_id) {
              throw new Error(requestError?.message || "deploy_request_not_found");
            }

            const { data: releaseRow, error: releaseError } = await supabase
              .from("version_releases_labeled")
              .select("id, build_number, channel, source_commit_sha, version_label")
              .eq("id", requestRow.release_id)
              .limit(1)
              .maybeSingle();
            if (releaseError || !releaseRow?.id) {
              throw new Error(releaseError?.message || "release_row_not_found");
            }

            const { data: artifactRow, error: artifactError } = await supabase
              .from("version_release_artifacts_labeled")
              .select("id, artifact_name, artifact_provider, artifact_path, metadata, github_run_id, github_repository, product_key, env_key, version_label, commit_sha")
              .eq("release_id", requestRow.release_id)
              .limit(1)
              .maybeSingle();
            let resolvedArtifact = artifactRow;
            if (!resolvedArtifact?.id) {
              const { data: fallbackArtifact, error: fallbackError } = await supabase
                .from("version_release_artifacts_labeled")
                .select("id, artifact_name, artifact_provider, artifact_path, metadata, github_run_id, github_repository, product_key, env_key, version_label, commit_sha")
                .eq("product_key", String(requestRow.product_key || ""))
                .eq("version_label", String(requestRow.version_label || ""))
                .order("created_at", { ascending: false })
                .limit(1)
                .maybeSingle();
              if (fallbackError || !fallbackArtifact?.id) {
                throw new Error(fallbackError?.message || artifactError?.message || "release_artifact_not_found");
              }
              resolvedArtifact = fallbackArtifact;
            }
            if (!resolvedArtifact?.artifact_name || !resolvedArtifact?.artifact_provider) {
              throw new Error("release_artifact_invalid");
            }

            const repo = String(resolvedArtifact.github_repository || "").trim() || process.env.GITHUB_REPOSITORY;
            const metadata =
              resolvedArtifact.metadata && typeof resolvedArtifact.metadata === "object"
                ? resolvedArtifact.metadata
                : {};
            const storageBucket =
              String(metadata.storage_bucket || "").trim() ||
              String(process.env.VERSIONING_ARTIFACTS_BUCKET || "").trim() ||
              "versioning-artifacts";
            const out = process.env.GITHUB_OUTPUT;
            if (!out) throw new Error("Missing GITHUB_OUTPUT");
            fs.appendFileSync(out, `artifact_id=${resolvedArtifact.id}\n`);
            fs.appendFileSync(out, `artifact_name=${resolvedArtifact.artifact_name}\n`);
            fs.appendFileSync(out, `artifact_provider=${resolvedArtifact.artifact_provider}\n`);
            fs.appendFileSync(out, `artifact_path=${resolvedArtifact.artifact_path || ""}\n`);
            fs.appendFileSync(out, `artifact_bucket=${storageBucket}\n`);
            fs.appendFileSync(out, `artifact_run_id=${resolvedArtifact.github_run_id || ""}\n`);
            fs.appendFileSync(out, `artifact_repo=${repo}\n`);
            fs.appendFileSync(out, `artifact_commit_sha=${resolvedArtifact.commit_sha || ""}\n`);
            fs.appendFileSync(out, `release_id=${requestRow.release_id || ""}\n`);
            fs.appendFileSync(out, `release_build_number=${releaseRow.build_number || ""}\n`);
            fs.appendFileSync(out, `release_channel=${releaseRow.channel || requestRow.env_key || ""}\n`);
            fs.appendFileSync(out, `release_version_label=${releaseRow.version_label || requestRow.version_label || ""}\n`);
          })().catch((error) => {
            console.error(error.message || error);
            process.exit(1);
          });
          NODE

      - name: Download release artifact from GitHub Actions
        if: ${{ steps.artifact_meta.outputs.artifact_provider == 'github_actions' }}
        uses: actions/download-artifact@v4
        with:
          name: ${{ steps.artifact_meta.outputs.artifact_name }}
          run-id: ${{ steps.artifact_meta.outputs.artifact_run_id }}
          repository: ${{ steps.artifact_meta.outputs.artifact_repo }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          path: downloaded-artifact

      - name: Download release artifact from Supabase Storage
        if: ${{ steps.artifact_meta.outputs.artifact_provider == 'supabase_storage' }}
        shell: bash
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SECRET_KEY: ${{ secrets.SUPABASE_SECRET_KEY }}
          ARTIFACT_BUCKET: ${{ steps.artifact_meta.outputs.artifact_bucket }}
          ARTIFACT_PATH: ${{ steps.artifact_meta.outputs.artifact_path }}
        run: |
          set -euo pipefail

          node <<'NODE'
          const fs = require("fs");
          const path = require("path");
          const { createClient } = require("@supabase/supabase-js");

          (async () => {
            const url = process.env.SUPABASE_URL;
            const key = process.env.SUPABASE_SECRET_KEY;
            const bucket = String(process.env.ARTIFACT_BUCKET || "").trim() || "versioning-artifacts";
            const artifactPath = String(process.env.ARTIFACT_PATH || "").trim();
            if (!url || !key) throw new Error("Missing SUPABASE_URL/SUPABASE_SECRET_KEY");
            if (!artifactPath) throw new Error("Missing ARTIFACT_PATH for supabase_storage provider");

            const supabase = createClient(url, key, {
              auth: { persistSession: false, autoRefreshToken: false },
            });

            const { data, error } = await supabase.storage.from(bucket).download(artifactPath);
            if (error || !data) throw new Error(error?.message || "artifact_storage_download_failed");

            const archivePath = path.resolve("downloaded-artifact.zip");
            const outDir = path.resolve("downloaded-artifact");
            const arrayBuffer = await data.arrayBuffer();
            fs.writeFileSync(archivePath, Buffer.from(arrayBuffer));
            fs.rmSync(outDir, { recursive: true, force: true });
            fs.mkdirSync(outDir, { recursive: true });
            console.log(`ARTIFACT_DOWNLOADED archive=${archivePath}`);
          })().catch((error) => {
            console.error(error.message || error);
            process.exit(1);
          });
          NODE

          unzip -q "downloaded-artifact.zip" -d "downloaded-artifact"

      - name: Validate artifact provider
        if: ${{ steps.artifact_meta.outputs.artifact_provider != 'github_actions' && steps.artifact_meta.outputs.artifact_provider != 'supabase_storage' }}
        shell: bash
        run: |
          set -euo pipefail
          echo "Provider no soportado: ${{ steps.artifact_meta.outputs.artifact_provider }}"
          exit 1

      - name: Prepare publish dir from artifact
        id: build
        shell: bash
        env:
          PRODUCT_KEY: ${{ inputs.product_key }}
        run: |
          set -euo pipefail

          source_dir="downloaded-artifact"
          if [[ ! -d "$source_dir" ]]; then
            echo "Artifact descargado no existe: $source_dir"
            exit 1
          fi

          if [[ "$PRODUCT_KEY" == "referidos_app" ]]; then
            rm -rf "apps/referidos-app/dist"
            mkdir -p "apps/referidos-app/dist"
            cp -R "${source_dir}/." "apps/referidos-app/dist/"
          elif [[ "$PRODUCT_KEY" == "prelaunch_web" ]]; then
            rm -rf "apps/prelaunch/dist"
            mkdir -p "apps/prelaunch/dist"
            cp -R "${source_dir}/." "apps/prelaunch/dist/"
          else
            echo "Producto no soportado para deploy artifact: $PRODUCT_KEY"
            exit 1
          fi

          echo "publish_dir=${source_dir}" >> "$GITHUB_OUTPUT"

      - name: Generar runtime app-config.js
        id: runtime_config
        shell: bash
        env:
          PUBLISH_DIR: ${{ steps.build.outputs.publish_dir }}
          RUNTIME_PRODUCT_KEY: ${{ inputs.product_key }}
          RUNTIME_ENV_KEY: ${{ inputs.env_key }}
          RUNTIME_APP_ID: ${{ steps.plan.outputs.obs_app_id }}
          RUNTIME_APP_VERSION: ${{ inputs.semver }}
          RUNTIME_BUILD_NUMBER: ${{ steps.artifact_meta.outputs.release_build_number }}
          RUNTIME_BUILD_ID: ${{ inputs.source_commit_sha }}
          RUNTIME_RELEASE_ID: ${{ steps.artifact_meta.outputs.release_id }}
          RUNTIME_ARTIFACT_ID: ${{ steps.artifact_meta.outputs.artifact_id }}
          RUNTIME_RELEASE_CHANNEL: ${{ steps.artifact_meta.outputs.release_channel }}
          RUNTIME_SOURCE_COMMIT_SHA: ${{ inputs.source_commit_sha }}
          RUNTIME_TENANT_HINT: ${{ steps.obs_tenant.outputs.tenant_name }}
          RUNTIME_SUPABASE_URL: ${{ steps.vite_supabase.outputs.vite_supabase_url }}
          RUNTIME_SUPABASE_ANON_KEY: ${{ steps.vite_supabase.outputs.vite_supabase_anon_key }}
        run: |
          set -euo pipefail

          node <<'NODE'
          const fs = require("fs");
          const path = require("path");
          const crypto = require("crypto");

          const publishDir = process.env.PUBLISH_DIR;
          const productKey = process.env.RUNTIME_PRODUCT_KEY;
          const runtimeBuildNumber = String(process.env.RUNTIME_BUILD_NUMBER || "").trim();
          const runtimeBuildId = runtimeBuildNumber || String(process.env.RUNTIME_BUILD_ID || "").trim();
          const baseConfig = {
            appEnv: process.env.RUNTIME_ENV_KEY,
            appId: process.env.RUNTIME_APP_ID,
            appVersion: process.env.RUNTIME_APP_VERSION,
            buildId: runtimeBuildId,
            buildNumber: runtimeBuildNumber || null,
            releaseId: process.env.RUNTIME_RELEASE_ID || null,
            artifactId: process.env.RUNTIME_ARTIFACT_ID || null,
            releaseChannel: process.env.RUNTIME_RELEASE_CHANNEL || process.env.RUNTIME_ENV_KEY || null,
            sourceCommitSha: process.env.RUNTIME_SOURCE_COMMIT_SHA,
            defaultTenantId: process.env.RUNTIME_TENANT_HINT || "ReferidosAPP",
            supabaseUrl: process.env.RUNTIME_SUPABASE_URL,
          };

          let windowKey = "";
          let runtimeConfig = {};

          if (productKey === "referidos_app") {
            windowKey = "__REFERIDOS_RUNTIME_CONFIG__";
            runtimeConfig = {
              ...baseConfig,
              supabaseAnonKey: process.env.RUNTIME_SUPABASE_ANON_KEY,
            };
          } else if (productKey === "prelaunch_web") {
            windowKey = "__PRELAUNCH_RUNTIME_CONFIG__";
            runtimeConfig = {
              ...baseConfig,
              appChannel: "prelaunch_web",
              supabasePublishableKey: process.env.RUNTIME_SUPABASE_ANON_KEY,
            };
          } else {
            throw new Error(`Producto no soportado para runtime config: ${productKey}`);
          }

          const filePath = path.join(publishDir, "app-config.js");
          fs.writeFileSync(filePath, `window.${windowKey} = ${JSON.stringify(runtimeConfig, null, 2)};\n`);
          console.log(`RUNTIME_CONFIG_WRITTEN ${filePath}`);

          const payloadJson = JSON.stringify(runtimeConfig);
          const configHash = crypto.createHash("sha256").update(payloadJson).digest("hex");
          const output = process.env.GITHUB_OUTPUT;
          if (output) {
            fs.appendFileSync(output, "runtime_config_key=app-config.js\n");
            fs.appendFileSync(output, `runtime_config_sha256=${configHash}\n`);
            fs.appendFileSync(output, "runtime_config_payload<<EOF\n");
            fs.appendFileSync(output, `${payloadJson}\n`);
            fs.appendFileSync(output, "EOF\n");
          }
          NODE

      - name: Upload sourcemaps + registrar release metadata
        id: sourcemaps
        shell: bash
        env:
          SUPABASE_URL: ${{ steps.obs.outputs.obs_url }}
          SUPABASE_SECRET_KEY: ${{ steps.obs.outputs.obs_secret }}
          OBS_TENANT_ID: ${{ steps.obs_tenant.outputs.tenant_id }}
          OBS_TENANT_NAME: ${{ steps.obs_tenant.outputs.tenant_name }}
          APP_ID: ${{ steps.plan.outputs.obs_app_id }}
          APP_VERSION: ${{ inputs.semver }}
          BUILD_ID: ${{ inputs.source_commit_sha }}
          APP_ENV: ${{ inputs.env_key }}
          VITE_APP_ID: ${{ steps.plan.outputs.obs_app_id }}
          VITE_APP_VERSION: ${{ inputs.semver }}
          VITE_BUILD_ID: ${{ inputs.source_commit_sha }}
          VITE_SOURCE_COMMIT_SHA: ${{ inputs.source_commit_sha }}
          VITE_COMMIT_SHA: ${{ inputs.source_commit_sha }}
          VITE_ENV: ${{ inputs.env_key }}
        run: |
          set -euo pipefail
          node tooling/observability/upload-sourcemaps.mjs --app "${{ steps.plan.outputs.upload_app }}"

      - name: Deploy artifact a Netlify
        id: deploy
        shell: bash
        run: |
          set -euo pipefail

          npx --yes netlify-cli@latest deploy \
            --filter "${{ steps.plan.outputs.netlify_filter }}" \
            --site "${{ steps.plan.outputs.site_id }}" \
            --auth "${NETLIFY_AUTH_TOKEN}" \
            --dir "${{ steps.build.outputs.publish_dir }}" \
            --prod \
            --message "versioning:${PRODUCT_KEY}:${ENV_KEY}:${SEMVER}:${SOURCE_COMMIT_SHA}" \
            --json > deploy-output.json

          node -e "const fs=require('fs');const out=JSON.parse(fs.readFileSync('deploy-output.json','utf8'));const id=out.id||out.deploy_id||out.deployId||'';const url=out.deploy_ssl_url||out.deploy_url||out.url||'';if(!id){console.error('deploy-output sin id');console.error(JSON.stringify(out,null,2));process.exit(1);}fs.appendFileSync(process.env.GITHUB_OUTPUT, 'deployment_id='+id+'\\n');if(url){fs.appendFileSync(process.env.GITHUB_OUTPUT, 'logs_url='+url+'\\n');}"

      - name: Crear tag de produccion
        id: tag_prod
        if: ${{ success() && inputs.env_key == 'prod' }}
        shell: bash
        run: |
          set -euo pipefail

          tag_name="v${SEMVER}"
          git fetch --tags origin

          if git rev-parse -q --verify "refs/tags/${tag_name}" >/dev/null; then
            echo "tag_name=${tag_name}" >> "$GITHUB_OUTPUT"
            echo "tag_created=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Use lightweight tag to avoid requiring git user identity in CI.
          git tag "${tag_name}" "${SOURCE_COMMIT_SHA}"
          git push origin "refs/tags/${tag_name}"

          echo "tag_name=${tag_name}" >> "$GITHUB_OUTPUT"
          echo "tag_created=true" >> "$GITHUB_OUTPUT"

      - name: Finalizar deploy en backend
        if: ${{ always() }}
        shell: bash
        env:
          FINAL_STATUS: ${{ job.status == 'success' && 'success' || 'failed' }}
          DEPLOYMENT_ID_RAW: ${{ steps.deploy.outputs.deployment_id }}
          DEPLOY_LOGS_URL_RAW: ${{ steps.deploy.outputs.logs_url }}
          TAG_NAME_RAW: ${{ steps.tag_prod.outputs.tag_name }}
          TAG_CREATED_RAW: ${{ steps.tag_prod.outputs.tag_created }}
          RELEASE_ID_RAW: ${{ steps.artifact_meta.outputs.release_id }}
          BUILD_NUMBER_RAW: ${{ steps.artifact_meta.outputs.release_build_number }}
          CHANNEL_RAW: ${{ steps.artifact_meta.outputs.release_channel }}
          RUNTIME_CONFIG_KEY_RAW: ${{ steps.runtime_config.outputs.runtime_config_key }}
          RUNTIME_CONFIG_SHA256_RAW: ${{ steps.runtime_config.outputs.runtime_config_sha256 }}
          RUNTIME_CONFIG_PAYLOAD_RAW: ${{ steps.runtime_config.outputs.runtime_config_payload }}
          GITHUB_RUN_URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          CALLBACK_ACTOR: ${{ inputs.actor }}
        run: |
          set -euo pipefail

          if [[ -z "${CALLBACK_URL}" ]]; then
            echo "CALLBACK_URL vacio"
            exit 1
          fi

          if [[ -z "${VERSIONING_DEPLOY_CALLBACK_TOKEN}" ]]; then
            echo "Falta secret VERSIONING_DEPLOY_CALLBACK_TOKEN en GitHub"
            exit 1
          fi

          deployment_id="${DEPLOYMENT_ID_RAW:-$DEPLOY_EXECUTION_ID}"
          logs_url="${DEPLOY_LOGS_URL_RAW:-$GITHUB_RUN_URL}"
          actor="${CALLBACK_ACTOR:-${WORKFLOW_ACTOR:-github-actions}}"

          export DEPLOYMENT_ID_FINAL="${deployment_id}"
          export LOGS_URL_FINAL="${logs_url}"
          export ACTOR_FINAL="${actor}"

          node <<'NODE'
          (async () => {
            const callbackUrl = process.env.CALLBACK_URL;
            const callbackToken = process.env.VERSIONING_DEPLOY_CALLBACK_TOKEN;
            const buildNumber = Number(process.env.BUILD_NUMBER_RAW || 0);
            let runtimeConfigPayload = null;
            try {
              runtimeConfigPayload = process.env.RUNTIME_CONFIG_PAYLOAD_RAW
                ? JSON.parse(process.env.RUNTIME_CONFIG_PAYLOAD_RAW)
                : null;
            } catch {
              runtimeConfigPayload = null;
            }
            const payload = {
              request_id: process.env.REQUEST_ID,
              status: process.env.FINAL_STATUS || "failed",
              deployment_id: process.env.DEPLOYMENT_ID_FINAL || "",
              logs_url: process.env.LOGS_URL_FINAL || "",
              actor: process.env.ACTOR_FINAL || "github-actions",
              metadata: {
                trigger: "github_workflow_artifact_exact",
                product_key: process.env.PRODUCT_KEY,
                env_key: process.env.ENV_KEY,
                semver: process.env.SEMVER,
                source_commit_sha: process.env.SOURCE_COMMIT_SHA,
                source_branch: process.env.SOURCE_BRANCH || null,
                target_branch: process.env.TARGET_BRANCH || null,
                release_id: process.env.RELEASE_ID_RAW || null,
                build_number: Number.isFinite(buildNumber) && buildNumber > 0 ? buildNumber : null,
                channel: process.env.CHANNEL_RAW || process.env.ENV_KEY || null,
                github_run_id: process.env.GITHUB_RUN_ID,
                github_run_number: process.env.GITHUB_RUN_NUMBER,
                github_run_url: process.env.GITHUB_RUN_URL,
                github_repository: process.env.GITHUB_REPOSITORY,
                tag_name: process.env.TAG_NAME_RAW || null,
                tag_created: process.env.TAG_CREATED_RAW || null,
                artifact_id: "${{ steps.artifact_meta.outputs.artifact_id }}" || null,
                artifact_name: "${{ steps.artifact_meta.outputs.artifact_name }}" || null,
                artifact_run_id: "${{ steps.artifact_meta.outputs.artifact_run_id }}" || null,
                artifact_repository: "${{ steps.artifact_meta.outputs.artifact_repo }}" || null,
                runtime_config: {
                  config_key: process.env.RUNTIME_CONFIG_KEY_RAW || "app-config.js",
                  config_format: "json",
                  config_hash_sha256: process.env.RUNTIME_CONFIG_SHA256_RAW || null,
                  payload: runtimeConfigPayload,
                },
              },
            };

            const res = await fetch(callbackUrl, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "x-versioning-callback-token": callbackToken,
              },
              body: JSON.stringify(payload),
            });

            const text = await res.text();
            let parsed = {};
            try {
              parsed = text ? JSON.parse(text) : {};
            } catch {
              parsed = { raw: text };
            }

            if (!res.ok || parsed.ok === false) {
              console.error("Callback failed", {
                status: res.status,
                parsed,
              });
              process.exit(1);
            }

            console.log("Callback ok", parsed);
          })().catch((error) => {
            console.error("Callback exception", error);
            process.exit(1);
          });
          NODE
